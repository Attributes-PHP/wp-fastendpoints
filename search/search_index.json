{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WP-FastEndpoints","text":"<p>WP-FastEndpoints is an elegant way of writing custom WordPress REST endpoints with a focus on simplicity and readability.</p> <ul> <li>Explore our docs at WP-FastEndpoints Docs \u00bb</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Validates data via type-hints</li> <li>Removes unwanted fields from responses</li> <li>Middlewares support</li> <li>No magic router. It uses WordPress <code>register_rest_route</code></li> <li>Able to treat plugins as dependencies via WP-FastEndpoints Depends</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>PHP 8.1+</li> <li>WordPress 6.x</li> <li>attributes-php/validation</li> <li>attributes-php/serialization</li> <li>php-di/invoker</li> </ul> <p>We aim to support versions that haven't reached their end-of-life.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require attributes-php/wp-fastendpoints\n</code></pre> <p>WP FastEndpoints was created by Andr\u00e9 Gil and is open-sourced software licensed under the MIT license.</p>"},{"location":"advanced-user-guide/","title":"Advanced User Guide","text":"<p>The Quick Start should be able to get you a feel of the main features of WP-FastEndpoints.</p> <p>However, it's possible that the solution for your use case might not be in the Quick Start tutorial. In the next sections we will take a look at further functionalities that WP-FastEndpoints provides.</p>"},{"location":"advanced-user-guide/dependency-injection/","title":"Dependency Injection","text":"<p>Each REST endpoint has its unique logic. Same goes with the data that it needs to work.</p> <p>For that reason, WP-FastEndpoints provides dependency injection support for all handlers e.g. permission handlers, main endpoint handler and middlewares.</p> <p>With dependency injection our endpoints do look much cleaner \u2728\ud83e\uddf9</p> With dependency injectionNo dependency injection <pre><code>// We only need the ID. So we type $ID\n$router-&gt;get('/posts/(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    return get_post($ID);\n});\n\n// We don't need anything. So no arguments are defined :D\n$router-&gt;get('/posts/random', function () {\n    $allPosts = get_posts();\n    return $allPosts ? $allPosts[array_rand($allPosts)] : new WpError(404, 'No posts found');\n});\n</code></pre> <pre><code>// Unable to fetch a dynamic parameter. Have to work with the $request argument\n$router-&gt;get('/posts/(?P&lt;ID&gt;[\\d]+)', function ($request) {\n    return get_post($request-&gt;get('ID'));\n});\n\n// Forced to accept $request even if not used :(\n$router-&gt;get('/posts/random', function ($request) {\n    $allPosts = get_posts();\n    return $allPosts ? $allPosts[array_rand($allPosts)] : new WpError(404, 'No posts found');\n});\n</code></pre>"},{"location":"advanced-user-guide/middlewares/","title":"Middlewares","text":"<p>Another cool feature of WP-FastEndpoints is the support for middlewares.</p> <p>Middlewares are pieces of code that can either run before and/or after a request is handled.</p> <p>At this stage, you might be already familiar with both the <code>schema(...)</code> and <code>returns(...)</code> middlewares. However, you can also create your own.</p> <pre><code>use Attributes\\Wp\\FastEndpoints\\Contracts\\Middleware;\n\nclass MyCustomMiddleware extends Middleware\n{\n    /**\n    * Create this function if you want that your middleware is\n    * triggered when it receives a request and after checking\n    * the user permissions.\n     */\n    public function onRequest(/* Type what you need */)\n    {\n        return;\n    }\n\n    /**\n    * Create this function when you want your middleware to be\n    * triggered before sending a response to the client \n     */\n    public function onResponse(/* Type what you need */) {\n        return;\n    }\n}\n\n// Attach middleware to endpoint\n$router-&gt;get('/test', function () {\n    return true;\n})\n-&gt;middleware(new MyCustomMiddleware());\n</code></pre> Tip <p>You can create both methods in a middleware: <code>onRequest</code> and <code>onResponse</code>. However, to save some CPU cycles only create the one you need [CPU emoji]</p>"},{"location":"advanced-user-guide/middlewares/#responses","title":"Responses","text":"<p>If you need you can also take advantage of either WP_Error and WP_REST_Response to send a direct response to the client. See Responses page for more info</p>"},{"location":"advanced-user-guide/plugins-as-dependencies/","title":"Treat plugins as dependencies","text":"<p>One of the main strengths of WordPress is the wide range of plugins available which allow us to fully customise a website in a short time period. However, every time a plugin is added it can negatively impact the performance of our API endpoints, because even though those endpoints might not need some of the activated plugins to work properly, they will still be loaded.</p> <p>To address this issue WP-FastEndpoints Depends was created to enable us to treat plugins as REST endpoint dependencies.</p>"},{"location":"advanced-user-guide/plugins-as-dependencies/#adding-another-plugin","title":"Adding another plugin?? \ud83d\ude31","text":"<p>Yes, this is a plugin! It could seem counterintuitive that adding another plugin could positively impact our API endpoints. However, given that in most cases our API endpoints don't need all the plugins that are active e.g. BuddyPress, Elementor it can actually improve your API endpoints.</p>"},{"location":"advanced-user-guide/plugins-as-dependencies/#how-it-works","title":"How it works?","text":"<p>Given this plugin needs to be setup as a MU-plugin it will always run before any regular plugin which allow us to decide which plugins are necessary for a given REST endpoint before loading them.</p>"},{"location":"advanced-user-guide/plugins-as-dependencies/#how-to-use-it","title":"How to use it?","text":"<p>Currently, we support both native WP endpoints and FastEndpoints \ud83d\ude0a</p> With FastEndpointsNative WP endpoints <pre><code>$router-&gt;get('/example/all-plugins', function () {\n    return \"Loads all active plugins\";\n});\n\n$router-&gt;get('/example/buddypress', function () {\n    return \"Only MyPlugin and BuddyPress plugins are loaded\"; \n})-&gt;depends(['my-plugin', 'buddypress']);\n</code></pre> <pre><code>// Loads all active plugins\nregister_rest_route('native/v1', 'example/all-plugins', [\n    'methods' =&gt; 'GET',\n    (...)\n]);\n\n// Only MyPlugin and BuddyPress plugins are loaded\nregister_rest_route('native/v1', 'example/buddypress', [\n    'methods' =&gt; 'GET',\n    'depends' =&gt; ['my-plugin', 'buddypress'],\n    (...)\n]);\n</code></pre> Tip <p>By default, if no dependencies are specified in an endpoint it assumes that all active plugins needs to be loaded. This behaviour could be overridden for a given set of WP-FastEndpoint's by setting router dependencies e.g. <code>$router-&gt;depends(['my-plugin'])</code></p>"},{"location":"advanced-user-guide/plugins-as-dependencies/#router-vs-endpoint-dependencies","title":"Router vs Endpoint dependencies","text":"<p>With WP-FastEndpoint's we are able to either define global endpoint dependencies via router dependencies or specific endpoint dependencies.</p> <p>One common scenario where router dependencies might be useful is when we want to change the default behaviour of loading all active plugins per endpoint.</p> <pre><code>$router = new \\Attributes\\Wp\\FastEndpoints\\Router('my-api', 'v1');\n$router-&gt;depends(['my-plugin']); // All endpoints and sub-routers would have this dependency\n</code></pre> <p>Danger</p> <p>When adding dependencies to endpoints, make sure to at least include the given plugin that holds those endpoints. For instance, if your endpoints reside inside a plugin with a slug <code>my-plugin</code> you have to set the dependencies to <code>['my-plugin']</code> otherwise when a request is received for that endpoint <code>my-plugin</code> will not be loaded.</p>"},{"location":"advanced-user-guide/plugins-as-dependencies/#endpoint-dependencies-up-to-date","title":"Endpoint dependencies up-to-date","text":"<p>Under the hood, this plugin generates a config file with all the route dependencies (see example). To have the most up-to-date endpoint dependencies, make sure to either:</p> <ul> <li>run the <code>wp fastendpoints depends</code> command or </li> <li>activate any plugin on the website - this also triggers the re-generation of the route dependencies</li> </ul>"},{"location":"advanced-user-guide/plugins-as-dependencies/#useful-constants","title":"Useful constants","text":"<ul> <li>FASTENDPOINTS_DEPENDS_ENABLED - If set to false, always loads all active plugins. Useful for local development </li> <li>FASTENDPOINTS_DEPENDS_CONFIG_FILEPATH - Overrides dependencies config file path</li> <li>FASTENDPOINTS_DEPENDS_REFRESH_ON_PLUGIN_ACTIVATION - If set to false, disables re-generating endpoint dependencies when any plugin is activated</li> </ul>"},{"location":"advanced-user-guide/request-life-cycle/","title":"Request Life Cycle","text":"<p>In WP-FastEndpoints an endpoint can have multiple optional handlers attached to:</p> <ol> <li>Permission handlers via <code>hasCap(...)</code> or <code>permission(...)</code> - Used to check for user permissions</li> <li>Middlewares<ol> <li>Request Payload Schema Middleware via <code>schema(...)</code> - Validates the request payload</li> <li>Response Schema Middleware via <code>returns(...)</code> - Makes sure that the proper response is sent to the client</li> <li>Custom middlewares via <code>middleware(...)</code> - Any other custom logic that you might want to run</li> </ol> </li> </ol>"},{"location":"advanced-user-guide/request-life-cycle/#permission-handlers","title":"Permission handlers","text":"<p>When a request is received the first handlers to run are the permissions handlers. Permission handlers are called by WordPress via <code>permission_callback</code>.</p> <p>In contrast to WordPress, you can have one or multiple permission handlers attached to the same endpoint.</p> Note <p>In the background all permission handlers are wrapped into one callable which is later on used as <code>permission_callback</code> by the endpoint</p> <p>These handlers will then be called in the same order as they were attached. For instance:</p> <pre><code>$router-&gt;get('/test', function () {return true;})\n-&gt;hasCap('read')                # Called first\n-&gt;hasCap('edit_posts')          # Called second if the first one was successful\n-&gt;permission('__return_true')   # Called last if both the first and second were successful\n</code></pre>"},{"location":"advanced-user-guide/request-life-cycle/#middlewares","title":"Middlewares","text":"<p>If all the permission handlers are successful the next set of handlers that run are the middlewares which implement the <code>onRequest</code> function.</p> <p>Remember that a middleware can implement <code>onRequest</code> and/or <code>onResponse</code> functions. The first one, runs before the main endpoint handler and the later one should run after the main endpoint handler.</p> <p>Warning</p> <p>Please bear in mind that if either a WP_Error or a WP_REST_Response is returned by the main endpoint handler following middlewares will not run. See Responses page for more info.</p>"},{"location":"advanced-user-guide/request-life-cycle/#onrequest","title":"onRequest","text":"<p>Same as with the permission handlers, middlewares are called with the same order that they were attached.</p> <pre><code>class OnRequestMiddleware extends \\Attributes\\Wp\\FastEndpoints\\Contracts\\Middleware\n{\n    public function onRequest(/* Type what you need */){\n        return;\n    }\n}\n\n$router-&gt;post('/test', function () {return true;})\n-&gt;middleware(OnRequestMiddleware()) # Called first\n-&gt;schema('Basics/Bool');            # Called second\n</code></pre>"},{"location":"advanced-user-guide/request-life-cycle/#onresponse","title":"onResponse","text":"<p>Likewise, middlewares implementing onResponse functions will be triggered in the same order as they were attached.</p> <pre><code>class OnResponseMiddleware extends \\Attributes\\Wp\\FastEndpoints\\Contracts\\Middleware\n{\n    public function onResponse(/* Type what you need */){\n        return;\n    }\n}\n\n$router-&gt;post('/test', function () {return true;})\n-&gt;returns('Basics/Bool')                # Called first\n-&gt;middleware(OnResponseMiddleware());   # Called second\n</code></pre>"},{"location":"advanced-user-guide/responses/","title":"Responses","text":"<p>When building an API sometimes we want to return a response directly to the client. For example:</p> <pre><code>$router-&gt;get('/posts/(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    return get_post($ID);\n})\n-&gt;returns('Posts/Get');  // It will raise a 422 HTTP error when we are unable to find a post\n</code></pre> <p>The code above, will raise a 422 HTTP status code error when ever we are unable to find a given post. This is where returning a message directly to the client can be useful.</p>"},{"location":"advanced-user-guide/responses/#early-return","title":"Early return","text":"<p>To trigger those scenarios we can either return a WP_Error or a WP_REST_Response.</p> WP_REST_ResponseWP_Error <pre><code>$router-&gt;get('/posts/(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = get_post($ID);\n    return $post ?: new WP_REST_Response(\"No posts found\", 404);\n})\n-&gt;returns('Posts/Get');  // This will not be triggered if no posts are found\n</code></pre> <pre><code>$router-&gt;get('/posts/(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = get_post($ID);\n    return $post ?: new WpError(404, \"No posts found\");\n})\n-&gt;returns('Posts/Get');  // This will not be triggered if no posts are found\n</code></pre>"},{"location":"advanced-user-guide/responses/#difference-between-returning-wp_rest_response-or-wp_error","title":"Difference between returning WP_REST_Response or WP_Error","text":"<p>The main difference between returning a WP_Error or a WP_REST_Response is regarding the JSON returned in the body.</p> WP_REST_ResponseWP_Error <pre><code>\"No posts found\"\n</code></pre> <pre><code>{\n    \"error\": 404,\n    \"message\": \"No posts found\",\n    \"data\": {\n        \"status\": 404\n    }\n}\n</code></pre>"},{"location":"quick-start/","title":"Quick Start","text":"<p>To better exemplify the benefits of using FastEndpoints we are going to build an API for manipulating blog posts.</p> <p>This API will be able to:</p> <ul> <li>Create</li> <li>Retrieve and</li> <li>Delete a blog post</li> </ul> <p>Full source code can be found at Attributes-PHP/wp-fastendpoints-my-plugin \u00bb</p>"},{"location":"quick-start/#plugin-code-structure","title":"Plugin code structure \ud83d\udd28","text":"<p>To hold this API we are going to create a plugin called MyPLugin - don't forget that logic shouldn't be contained in a theme - with the following structure:</p> <pre><code>my-plugin\n\u2502   my-plugin.php  # Registers the plugin provider\n\u2502   composer.json\n\u2502\n\u2514\u2500\u2500\u2500src\n\u2502   \u2502   constants.php\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500Api\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500\u2500Routers\n\u2502   \u2502   \u2502   \u2502   Posts.php  # Holds our custom endpoints\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500\u2500Models  # Holds classes to validate data\n\u2502   \u2502       \u2502   Posts.php\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500Providers\n\u2502       \u2502   ApiServiceProvider.php       # Registers all routers\n\u2502       \u2502   MyPluginProvider.php         # Bootstraps our plugin\n\u2502       \u2502   ProviderContract.php\n\u2502\n\u2514\u2500\u2500\u2500tests\n</code></pre>"},{"location":"quick-start/router/","title":"Router","text":"<p>The first thing we need to do is to create a Router.</p> Api/Routers/Posts.php<pre><code>&lt;?php\nuse Attributes\\Wp\\FastEndpoints\\Router;\n\n$router = new Router('posts');\n</code></pre> <p>A router is a class which allow us to attach and register endpoints.</p> <p>An application can have one or multiple routers. One main benefit of using multiple routers is to group endpoints by same namespace and (optionally) same version. For instance, in this tutorial we are going group all sub-routers, into another router with a namespace and version <code>my-plugin/v1</code></p>"},{"location":"quick-start/router/#define-the-shape-of-the-data","title":"Define the shape of the data","text":"<p>Each endpoint might require different types of data. Thanks to Attributes-PHP/validation we can simply create our own PHP classes with the shape of the data we need and use them to validate our request payload via type-hinting \ud83e\udd2f</p> Api/Models/Posts.php<pre><code>&lt;?php\nnamespace MyPlugin\\Api\\Models;\n\nuse Attributes\\Options\\AliasGenerator;\nuse Attributes\\Serialization\\SerializableTrait;\nuse Respect\\Validation\\Rules;\n\nenum Status: string\n{\n    case PUBLISH = 'publish';\n    case DRAFT = 'draft';\n    case PRIVATE = 'private';\n}\n\n#[AliasGenerator('snake')]\nclass Post\n{\n    use SerializableTrait;\n\n    #[Rules\\Positive]\n    public int $ID;\n    #[Rules\\Positive]\n    public int $postAuthor;\n    public string $postTitle;\n    public Status $postStatus;\n}\n</code></pre> <ol> <li>Allows looking up for snake case properties e.g. post_author.    More options at Attributes-PHP/options \u00bb</li> <li>Allow us to convert this instance into a dictionary via <code>$instance-&gt;serialize()</code></li> <li>Supports any Respect Validation rules</li> </ol>"},{"location":"quick-start/router/#create-a-post","title":"Create a post","text":"<p>Let's now create an endpoint which needs this type of data.</p> Api/Routers/Posts.php<pre><code>&lt;?php\nuse MyPlugin\\Api\\Models\\Post;\n\n$router-&gt;post('/', function (Post #(1) $post, WP_REST_Response #(2) $response) {\n    $response-&gt;set_status(201);\n    $payload = $post-&gt;serialize();\n\n    return wp_insert_post($payload, true);\n})\n    -&gt;hasCap('publish_posts');\n</code></pre> <ol> <li>By default, class-based type-hints will look for the data either in get_json_params or    get_body_params. To change    this behavior see Dependency injection</li> <li>Custom dependencies can also be injected via <code>$router-&gt;inject</code>. See inject custom dependencies</li> </ol> <p>When a request is received by this endpoint the following happens:</p> <ol> <li>First, the user permissions are checked - ensuring that only users with the publish_posts capability are     able to trigger this endpoint </li> <li>Second, if successful, the request payload is validated and populated into an instance of the <code>MyPlugin\\Api\\Models\\Post</code>    class. By default, for classes only, WP-FastEndpoints will look for the data either in    get_json_params or    get_body_params, depending on the    type of request. This behaviour can be changed via attributes though, see this page for more info.</li> <li>Third, the handler is called and creates a new blog post.</li> </ol>"},{"location":"quick-start/router/#retrieve-a-post","title":"Retrieve a post","text":"<p>A great thing of dependency injection is that you only type what you need. And if you only need the ID of a post, so be it \ud83d\ude0a</p> Api/Routers/Posts.php<pre><code>&lt;?php\nuse Attributes\\Wp\\FastEndpoints\\Helpers\\WpError;\nuse Respect\\Validation\\Rules;\nuse MyPlugin\\Api\\Models\\Post;\n\n$router-&gt;get('(?P&lt;ID&gt;[\\d]+)', function (#[Rules\\Positive] #(1) int $ID) {\n    $post = get_post($ID);\n\n    return $post ?: new WpError(404, 'Post not found'); #(2)\n})\n    -&gt;returns(Post::class)\n    -&gt;hasCap('read');\n</code></pre> <ol> <li>Yes, endpoint arguments do support any Respect Validation rules</li> <li>WpError is simply a subclass    of WP_Error which automatically set's the HTTP status code on the response data as well</li> </ol> <p>When a request is received, the following happens:</p> <ol> <li>First, we ensure the user has the read capability</li> <li>Second, we ensure that the ID parameter is a valid positive integer. By default, built-in type-hints lookup for    the data in the following order: 1) get_url_params    and then 2) get_query_params</li> <li>Lastly, if neither WP_Error or WP_REST_Response is returned by the handler, the <code>returns(Post::class)</code> will ensure    that the response sent to the client will only contain the fields specified in the <code>MyPlugin\\Api\\Models\\Post</code> class. You    could also ignore some fields via <code>Attributes\\Options\\Ignore</code> attribute from Attributes-PHP/options</li> </ol>"},{"location":"quick-start/router/#delete-a-post","title":"Delete a post","text":"<p>A common scenario while building API's is to ensure that a user has permissions to a particular resource, in this case a blog post.</p> Api/Routers/Posts.php<pre><code>&lt;?php\nuse Attributes\\Wp\\FastEndpoints\\Helpers\\WpError;\nuse Respect\\Validation\\Rules;\nuse MyPlugin\\Api\\Models\\Post;\n\n$router-&gt;delete('(?P&lt;ID&gt;[\\d]+)', function (#[Rules\\Positive] int $ID) {\n    return wp_delete_post($ID) ?: new WpError(500, 'Unable to delete post');\n})\n    -&gt;returns(Post::class)\n    -&gt;hasCap('delete_post', '&lt;ID&gt;');\n</code></pre> <p>In this scenario, only user's with permissions to delete the specific blog post with the provided <code>&lt;ID&gt;</code> would be able to successfully trigger this endpoint.</p>"},{"location":"quick-start/router/#everything-together","title":"Everything together","text":"Api/Routers/Posts.php<pre><code>&lt;?php\n/* Holds REST endpoints to interact with blog posts */\n\ndeclare(strict_types=1);\n\nuse Attributes\\Wp\\FastEndpoints\\Helpers\\WpError;\nuse Attributes\\Wp\\FastEndpoints\\Router;\nuse MyPlugin\\Api\\Models\\Post;\nuse Respect\\Validation\\Rules;\n\n$router = new Router('posts');\n\n$router-&gt;post('/', function (Post $post, WP_REST_Response $response) {\n    $response-&gt;set_status(201);\n    $payload = $post-&gt;serialize();\n\n    return wp_insert_post($payload, true);\n})\n    -&gt;hasCap('publish_posts');\n\n$router-&gt;get('(?P&lt;ID&gt;[\\d]+)', function (#[Rules\\Positive] int $ID) {\n    $post = get_post($ID);\n\n    return $post ?: new WpError(404, 'Post not found');\n})\n    -&gt;returns(Post::class)\n    -&gt;hasCap('read');\n\n$router-&gt;delete('(?P&lt;ID&gt;[\\d]+)', function (#[Rules\\Positive] int $ID) {\n    return wp_delete_post($ID) ?: new WpError(500, 'Unable to delete post');\n})\n    -&gt;returns(Post::class)\n    -&gt;hasCap('delete_post', '&lt;ID&gt;');\n\n// IMPORTANT: If no service provider is used make sure to set a version to the $router and call\n//            the following function here:\n// $router-&gt;register();\n\n// Used later on by the ApiProvider\nreturn $router;\n</code></pre>"},{"location":"quick-start/service-provider/","title":"Service Provider","text":"<p>Now that we have our endpoints ready, the last step is to register them. You can register a router individually or by grouping all of them into a single main router and register only that main router. The latter is what we are going to do. </p> Providers/ApiProvider.php<pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace MyPlugin\\Providers;\n\nuse Attributes\\Wp\\FastEndpoints\\Router;\n\nclass ApiProvider implements ProviderContract\n{\n    protected Router $appRouter;\n\n    public function register(): void\n    {\n        $this-&gt;appRouter = new Router('my-plugin', 'v1');\n        foreach (glob(\\ROUTERS_DIR.'/*.php') as $filename) {\n            $router = require $filename;\n            $this-&gt;appRouter-&gt;includeRouter($router);  #(1)\n        }\n        $this-&gt;appRouter-&gt;register(); #(2)\n    }\n}\n</code></pre> <ol> <li>By including a router the namespace and version of the parent router will be inherited e.g. /my-plugin/v1/posts/(?P[\\d]+) <li>Internally, this function relies on the rest_api_init hook.</li>"},{"location":"quick-start/service-provider/#its-running","title":"It's running","text":"<p>\ud83c\udf89 Congrats you just created your first set of WP FastEndpoints</p> <p>Now let's see how to test them! \ud83d\ude04</p> <p>Full source code can be found at attributes-php/wp-fastendpoints-my-plugin \u00bb</p>"},{"location":"quick-start/tests/","title":"Testing","text":"<p>To test our router endpoints we are going to use Pest PHP. Pest is a testing framework which makes PHP testing a breeze. Besides, the creator of Pest is Portuguese and studied at the same university as me which is a bonus \ud83c\udf1f\ud83d\ude02</p> <p>However, if you have a preference for some other testing framework, the same principles apply</p>"},{"location":"quick-start/tests/#testing-dependencies","title":"Testing dependencies","text":"<p>To allow us mocking classes and function we will be using Mockery</p> <pre><code>composer require mockery/mockery --dev\n</code></pre>"},{"location":"quick-start/tests/#testing-structure","title":"Testing structure","text":"<p>We are going to write unit and integration tests. Our code structure would look like the following:</p> <pre><code>my-plugin\n\u2502   (...)\n\u2502\n\u2514\u2500\u2500\u2500src\n\u2502       (...)\n\u2502\n\u2514\u2500\u2500\u2500tests\n    \u2502   bootstrap.php   # Loads WordPress for integration tests\n    \u2502   Helpers.php     # (optional) Helper functions\n    \u2502   Pest.php        # Pest configuration file\n    \u2502\n    \u2514\u2500\u2500\u2500Integration\n    \u2502   \u2502    PostsApiTest.php\n    \u2502\n    \u2514\u2500\u2500\u2500Unit\n        \u2502    PostsApiTest.php\n</code></pre>"},{"location":"quick-start/tests/integration/","title":"Integration Tests","text":"<p>Integration tests, are a bit tricky to set up.</p> <p>The following needs to happen in order to successfully run them:</p> <ol> <li>Load WordPress</li> <li>Replace the default TestCase class with another one which eases testing in WordPress    (e.g. to easily create users or posts)</li> <li>Create the REST server and boot it using the <code>rest_api_init</code>    hook</li> </ol>"},{"location":"quick-start/tests/integration/#wp-pest-to-the-rescue","title":"wp-pest to the rescue \ud83e\uddb8","text":"<p>However, thanks to wp-pest most of this trouble is no longer an issue. Via a simple command it solves most of the troubles for us! \ud83d\ude0e</p> <pre><code># Installs wp-pest\ncomposer require dingo-d/wp-pest --dev\n\n# Set's up WP\n./vendor/bin/wp-pest setup plugin --plugin-slug my-plugin --wp-version 6.8.2\n</code></pre> <p>Tip</p> <p>If you use attributes-php/wp-fastendpoints-my-plugin you can use the already configured <code>composer setup:wp:6.x</code> commands</p>"},{"location":"quick-start/tests/integration/#optional-changes","title":"Optional changes","text":"<p>If you take a closer look at the resultant tests structure you might notice that is slightly different from attributes-php/wp-fastendpoints-my-plugin. These changes are not mandatory and so, feel free to skip this section \u23e9</p> <p>The main reason of these differences is to allow us to run tests without the need to always specify a group of tests. Those changes include:</p> tests/Helpers.php<pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace MyPlugin\\Tests;\n\nclass Helpers\n{\n    /**\n     * Checks if weather we want to run integration tests or not\n     */\n    public static function isIntegrationTest(): bool\n    {\n        return isset($GLOBALS['argv']) &amp;&amp; in_array('--group=integration', $GLOBALS['argv'], true);\n    }\n}\n</code></pre> tests/Integration/PostsApiTest.php<pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace MyPlugin\\Tests\\Integration;\n\nuse MyPlugin\\Tests\\Helpers;\n\n// Needs to add this check to every Integration test file\nif (! Helpers::isIntegrationTest()) {\n    return;\n}\n</code></pre>"},{"location":"quick-start/tests/integration/#setup-and-teardown","title":"SetUp and TearDown","text":"<p>The last step before creating our integration tests, is to set up the REST server and trigger the <code>rest_api_init</code> hook.</p> tests/Integration/PostsApiTest.php<pre><code>&lt;?php\nbeforeEach(function () {\n    parent::setUp();\n\n    // Set up a REST server instance.\n    global $wp_rest_server;\n    $this-&gt;server = $wp_rest_server = new WP_REST_Server;\n    do_action('rest_api_init', $this-&gt;server);\n});\n\nafterEach(function () {\n    global $wp_rest_server;\n    $this-&gt;server = $wp_rest_server = null;\n\n    parent::tearDown();\n});\n</code></pre>"},{"location":"quick-start/tests/integration/#our-integration-test","title":"Our integration test \ud83d\ude43","text":"<p>Now that everything is configured we can start creating integration tests:</p> tests/Integration/PostsApiTest.php<pre><code>&lt;?php\ntest('Create a new post', function () {\n    // Create user with correct permissions\n    $userId = $this::factory()-&gt;user-&gt;create();\n    $user = get_user_by('id', $userId);\n    $user-&gt;add_cap('publish_posts');\n    // Make request as that user\n    wp_set_current_user($userId);\n    $request = new \\WP_REST_Request('POST', '/my-plugin/v1/posts');\n    $request-&gt;set_body_params([\n        'post_title' =&gt; 'My testing message',\n        'post_status' =&gt; 'publish',\n        'post_author' =&gt; $userId,\n    ]);\n    $response = $this-&gt;server-&gt;dispatch($request);\n    expect($response-&gt;get_status())-&gt;toBe(201);\n    $postId = $response-&gt;get_data();\n    // Check that the post details are correct\n    expect(get_post($postId))\n        -&gt;toBeInstanceOf(\\WP_Post::class)\n        -&gt;toHaveProperty('post_title', 'My testing message')\n        -&gt;toHaveProperty('post_status', 'publish')\n        -&gt;toHaveProperty('post_author', $userId);\n})-&gt;group('api', 'posts');\n</code></pre> <p>Here, we take advantage of the existent testing factories to create a single user with the necessary capability to publish posts. Then, we mimic a REST request from that given user, and lastly, we check if that blog post was created.</p>"},{"location":"quick-start/tests/unit/","title":"Unit Tests","text":"<p>To allow us unit test our router we would need to update the following line:</p> src/Api/Routers/Posts.php<pre><code>&lt;?php\n\n$router = $router ?? new Router('posts');\n</code></pre> <p>This change will allow us to pass a mocked router to easily test our endpoints.</p>"},{"location":"quick-start/tests/unit/#create-a-post","title":"Create a post","text":"<p>As an example we are going to create a unit test to ensure that the correct user permissions are set.</p> tests/Unit/PostsApiTest.php<pre><code>&lt;?php\ntest('Create post has correct permissions', function () {\n    // Create endpoint mock\n    $endpoint = $endpoint ?: Mockery::mock(Endpoint::class);\n    $endpoint\n        -&gt;shouldReceive('hasCap')\n        -&gt;once()\n        -&gt;with('publish_posts');\n    // Create router\n    $router = Mockery::mock(Router::class)\n        -&gt;shouldIgnoreMissing(Mockery::mock(Endpoint::class)-&gt;shouldIgnoreMissing(Mockery::self()));\n    $router\n        -&gt;shouldReceive('post')\n        -&gt;once()\n        -&gt;with('/', Mockery::type('callable'))\n        -&gt;andReturn($endpoint);\n    require \\ROUTERS_DIR.'/Posts.php';\n})-&gt;group('api', 'posts');\n</code></pre> <p>Please refer to the Attributes-PHP/wp-fastendpoints-my-plugin \u00bb for full source code</p>"}]}