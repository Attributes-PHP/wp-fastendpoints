{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WP-FastEndpoints","text":"<p>FastEndpoints is an elegant way of writing custom WordPress REST endpoints with a focus on readability and IDE auto completion support.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Decouples request validation from main logic</li> <li>Removes unwanted fields from responses</li> <li>Middlewares support</li> <li>IDE auto completion support</li> <li>No magic router. It uses WordPress <code>register_rest_route</code></li> <li>Support for newer JSON schema drafts thanks to json/opis</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>PHP 8.1+</li> <li>WordPress 6.x</li> <li>opis/json-schema</li> <li>php-di/invoker</li> </ul> <p>We aim to support versions that haven't reached their end-of-life.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require wp-fastendpoints\n</code></pre>"},{"location":"#sponsors","title":"Sponsors","text":""},{"location":"quick-start/","title":"Quick Start","text":"<p>To better exemplify the benefits of using FastEndpoints we are going to build an API for manipulating blog posts.</p> <p>This API will be able to:</p> <ul> <li>Create</li> <li>Retrieve</li> <li>Update and</li> <li>Delete a blog post</li> </ul> <p>Full source code can be found at matapatos/wp-fastendpoints-my-plugin \u00bb</p>"},{"location":"quick-start/#plugin-code-structure","title":"Plugin code structure \ud83d\udd28","text":"<p>To hold this API we are going to create a plugin called MyPLugin - don't forget that logic shouldn't be contained in a theme - with the following structure:</p> <pre><code>my-plugin\n\u2502   my-plugin.php  # Registers the plugin provider\n\u2502   composer.json\n\u2502\n\u2514\u2500\u2500\u2500src\n\u2502   \u2502   constants.php\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500Api\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500\u2500Routers\n\u2502   \u2502   \u2502   \u2502   Posts.php  # Holds our custom endpoints\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500\u2500Schemas\n\u2502   \u2502       \u2502\n\u2502   \u2502       \u2514\u2500\u2500\u2500Posts\n\u2502   \u2502           \u2502   CreateOrUpdate.json  # Validates our request payload\n\u2502   \u2502           \u2502   Get.json             # Discards unwanted fields from our response\n\u2502   \u2502\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500Providers\n\u2502       \u2502   ApiServiceProvider.php       # Registers all routers\n\u2502       \u2502   MyPluginProvider.php         # Bootstraps our plugin\n\u2502       \u2502   ProviderContract.php\n\u2502\n\u2514\u2500\u2500\u2500tests\n</code></pre>"},{"location":"quick-start/json-schemas/","title":"JSON Schemas","text":"<p>For this scenario, we are going to create two JSON schemas: 1) for validating the request payload and another 2) to discard unwanted fields from responses (e.g. sensitive information).</p>"},{"location":"quick-start/json-schemas/#request-payload-createupdate","title":"Request payload (create/update)","text":"<p>For the payload we decided to accept the following fields: 1) post_title, 2) post_status, 3) post_type and 4) optionally post_content</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"post_title\": {\n      \"type\": \"string\"\n    },\n    \"post_status\": {\n      \"enum\": [\"publish\", \"draft\", \"private\"],\n      \"default\": \"publish\"\n    },\n    \"post_type\": {\n      \"const\": \"post\"\n    },\n    \"post_content\": {\n      \"type\": \"string\",\n      \"contentMediaType\": \"text/html\"\n    }\n  },\n  \"required\": [\"post_title\", \"post_status\", \"post_type\"]\n}\n</code></pre>"},{"location":"quick-start/json-schemas/#response-retrieve","title":"Response (retrieve)","text":"<p>For the response we decided to only return the following fields: 1) post_title and 2) optionally post_excerpt</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"post_title\": {\n      \"type\": \"string\"\n    },\n    \"post_excerpt\": {\n      \"type\": \"string\",\n      \"contentMediaType\": \"text/html\"\n    }\n  },\n  \"required\": [\"post_title\"]\n}\n</code></pre>"},{"location":"quick-start/router/","title":"Router","text":"<p>The first thing we need to do is to create a Router.</p> <pre><code>&lt;?php\nuse Wp\\FastEndpoints\\Router;\n\n// Dependency injection to enable us to mock router in tests\n$router = $router ?? new Router('posts');\n</code></pre> <p>A router is just an instance which allow us to attach and register endpoints.</p> <p>We can have an application with one or multiple routers. One main benefit of using multiple routers is to group endpoints by same namespace and (optionally) same version. For instance, in this tutorial we are going to create a main router with a base namespace <code>my-plugin</code> and a version of <code>v1</code> which will add <code>/my-plugin/v1/</code> to the beginning of each attached endpoint from sub-routers.</p>"},{"location":"quick-start/router/#create-a-post","title":"Create a post","text":"<p>With the posts router in place we can now start attaching our endpoints. We start adding the one to that allows a user to create a blog post.</p> <pre><code>&lt;?php\n$router-&gt;post('/', function (\\WP_REST_Request $request): int|\\WP_Error {\n    $payload = $request-&gt;get_params();\n\n    return wp_insert_post($payload, true);\n})\n    -&gt;schema('Posts/CreateOrUpdate')\n    -&gt;hasCap('publish_posts');\n</code></pre> <p>When a request is received by this endpoint the following happens:</p> <p>1) Firstly, the user permissions are checked - Makes sure that the user has publish_posts capability 2) Then, if successful, it validates the request payload by using the Posts/CreateOrUpdate schema.    We still didn't specify where the endpoints should look for the schemas, but don't worry we are getting into that in a moment 3) Lastly, if the validation process also passes the handler is called.</p> <p>Info</p> <p>In this scenario we are not using a JSON schema to discard fields because the wp_insert_post either returns the ID of the post or a WP_Error which is already what we want \ud83d\ude0a</p>"},{"location":"quick-start/router/#retrieve-a-post","title":"Retrieve a post","text":"<p>Some endpoints however do need to return more complex objects. And in those cases JSON schemas can be of a great help.</p> <p>JSON schemas can help us to make sure that we are returning all the required fields as well as to avoid retrieving sensitive information. The last one is configurable.</p> <pre><code>&lt;?php\nuse Wp\\FastEndpoints\\Helpers\\WpError;\n\n$router-&gt;get('(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = get_post($ID);\n\n    return $post ?: new WpError(404, 'Post not found');\n})\n    -&gt;returns('Posts/Get')\n    -&gt;hasCap('read');\n</code></pre> <p>In this case, we didn't set a JSON schema on purpose because we only need the post_id which is already parsed by the regex rule - we could have made that rule to match only positive integers though \ud83e\udd14</p> <p>Going back to the endpoint, this is what happens if a request comes in:</p> <p>1) Firstly, it checks the user has read    capability - one of the lowest WordPress users capabilities 2) If so, it then calls the handler which either retrieves the post data (e.g. array or object)    or a WpError    in case that is not found. If a WpError or WP_Error is returned it stops further code execution    and returns that error message to the client - avoiding triggering response schema validation for example. 3) Lastly, if the post data is returned by the handler the response schema will be triggered    and will check the response according to the given schema (e.g. Posts/Get)</p> <p>Note</p> <p>The WpError is just a subclass of WP_Error which automatically set's the HTTP status code of the response</p>"},{"location":"quick-start/router/#update-a-post","title":"Update a post","text":"<p>Checking for user capabilities such as <code>publish_posts</code> and <code>read</code> is cool. However, in the real world we sometimes also need to check for a particular resource.</p> <pre><code>&lt;?php\n$router-&gt;put('(?P&lt;ID&gt;[\\d]+)', function (\\WP_REST_Request $request): int|\\WP_Error {\n    $payload = $request-&gt;get_params();\n\n    return wp_update_post($payload, true);\n})\n    -&gt;schema('Posts/CreateOrUpdate')\n    -&gt;hasCap('edit_post', '{ID}');\n</code></pre> <p>The code above is not that different from the one for creating a post. However, in the last line <code>hasCap('edit_post', '{post_id}')</code> the second parameter is a special one for FastEndpoints which will try to replace it by the post_id parameter.</p> <p>Warning</p> <p>FastEndpoints will only replace the {PARAM_NAME} if that parameter exists in the request payload. Otherwise, will not touch it. Also, bear in mind that the first stage in an endpoint is checking the user capabilities. As such, at that time the request params have not been already validated by the request payload schema.</p>"},{"location":"quick-start/router/#delete-a-post","title":"Delete a post","text":"<pre><code>&lt;?php\nuse Wp\\FastEndpoints\\Helpers\\WpError;\n\n$router-&gt;delete('(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = wp_delete_post($postId);\n\n    return $post ?: new WpError(500, 'Unable to delete post');\n})\n    -&gt;returns('Posts/Get')\n    -&gt;hasCap('delete_post', '{ID}');\n</code></pre>"},{"location":"quick-start/router/#everything-together","title":"Everything together","text":"<pre><code>&lt;?php\n\"\"\"\nApi/Endpoints/Posts.php\n\"\"\"\ndeclare(strict_types=1);\n\nnamespace MyPlugin\\Api\\Routers;\n\nuse Wp\\FastEndpoints\\Helpers\\WpError;\nuse Wp\\FastEndpoints\\Router;\n\n// Dependency injection to enable us to mock router in the tests\n$router = $router ?? new Router('posts');\n\n// Creates a post\n$router-&gt;post('/', function (\\WP_REST_Request $request): int|\\WP_Error {\n    $payload = $request-&gt;get_params();\n\n    return wp_insert_post($payload, true);\n})\n    -&gt;schema('Posts/CreateOrUpdate')\n    -&gt;hasCap('publish_posts');\n\n// Fetches a single post\n$router-&gt;get('(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = get_post($ID);\n\n    return $post ?: new WpError(404, 'Post not found');\n})\n    -&gt;returns('Posts/Get')\n    -&gt;hasCap('read');\n\n// Updates a post\n$router-&gt;put('(?P&lt;ID&gt;[\\d]+)', function (\\WP_REST_Request $request): int|\\WP_Error {\n    $payload = $request-&gt;get_params();\n\n    return wp_update_post($payload, true);\n})\n    -&gt;schema('Posts/CreateOrUpdate')\n    -&gt;hasCap('edit_post', '{ID}');\n\n// Deletes a post\n$router-&gt;delete('(?P&lt;ID&gt;[\\d]+)', function ($ID) {\n    $post = wp_delete_post($postId);\n\n    return $post ?: new WpError(500, 'Unable to delete post');\n})\n    -&gt;returns('Posts/Get')\n    -&gt;hasCap('delete_post', '{ID}');\n\n// IMPORTANT: If no service provider is used make sure to set a version to the $router and call\n//            the following function here:\n// $router-&gt;register();\n\n// Used later on by the ApiProvider\nreturn $router;\n</code></pre>"},{"location":"quick-start/service-provider/","title":"Service Provider","text":"<p>Now that we have our posts router built the last main three bits missing are the following:</p> <p>1) create a main router to hold all sub-routers (e.g. posts router) 2) specifying where to look for the JSON schemas (one or multiple directories) and 3) lastly register the router. This is what adds the <code>rest_api_init</code> hook for registering all    the endpoints.</p> <pre><code>&lt;?php\n\"\"\"\nsrc/Providers/ApiProvider.php\n\"\"\"\ndeclare(strict_types=1);\n\nnamespace MyPlugin\\Providers;\n\nuse Wp\\FastEndpoints\\Router;\n\nclass ApiProvider implements ProviderContract\n{\n    protected Router $appRouter;\n\n    public function register(): void\n    {\n        $this-&gt;appRouter = new Router('my-plugin', 'v1');\n        $this-&gt;appRouter-&gt;appendSchemaDir(\\SCHEMAS_DIR, 'http://www.my-plugin.com');\n        foreach (glob(\\ROUTERS_DIR.'/*.php') as $filename) {\n            $router = require $filename;\n            $this-&gt;appRouter-&gt;includeRouter($router);\n        }\n        $this-&gt;appRouter-&gt;register();\n    }\n}\n</code></pre> <p>Tip</p> <p>Adding the schema directory to the main router will share it across   all sub-routers.</p>"},{"location":"quick-start/service-provider/#its-running","title":"It's running","text":"<p>\ud83c\udf89 Congrats you just created your first set of REST FastEndpoints</p> <p>Now let's see how to test it out! \ud83d\ude04</p> <p>Full source code can be found at matapatos/wp-fastendpoints-my-plugin \u00bb</p>"},{"location":"quick-start/tests/","title":"Testing","text":"<p>For testing our WP-FastEndpoints router we are going to use pest/php.</p> <p>Pest is a testing framework that makes it super easy to test functionality in PHP, that's why we are going to use it here. However, if you have a preference for some other testing framework, the some principles should apply \ud83d\ude0a</p> <p>Full source code can be found at matapatos/wp-fastendpoints-my-plugin \u00bb</p>"},{"location":"quick-start/tests/#testing-dependencies","title":"Testing dependencies","text":"<p>First, let's add all the necessary testing dependencies:</p> <pre><code>composer require mockery/mockery --dev  # For mocking classes/functions\ncomposer require dingo-d/wp-pest --dev  # Adds Pest support for integration tests\n</code></pre>"},{"location":"quick-start/tests/#testing-structure","title":"Testing structure","text":"<p>For testing our plugin, we are going to assume the following structure:</p> <pre><code>my-plugin\n\u2502   my-plugin.php\n\u2502   composer.json\n\u2502\n\u2514\u2500\u2500\u2500src\n\u2502       (...)\n\u2502\n\u2514\u2500\u2500\u2500tests\n    \u2502   bootstrap.php   # Loads WordPress for integration tests\n    \u2502   Helpers.php     # (optional) Helper functions\n    \u2502   Pest.php        # Pest configuration file\n    \u2502\n    \u2514\u2500\u2500\u2500Integration\n    \u2502       PostsApiTest.php\n    \u2502\n    \u2514\u2500\u2500\u2500Unit\n            PostsApiTest.php\n</code></pre>"},{"location":"quick-start/tests/integration/","title":"Integration Tests","text":"<p>Integration tests, are a bit tricky to set up.</p> <p>The following needs to happen in order to successfully run them:</p> <p>1) Load WordPress 2) Replace the default TestCase class with one with enhanced WordPress functionalities    (e.g. to easily create users or posts) 3) Create the REST server and boot it using the <code>rest_api_init</code>    hook</p>"},{"location":"quick-start/tests/integration/#wp-pest-to-the-rescue","title":"wp-pest to the rescue \ud83e\uddb8","text":"<p>However, thanks to wp-pest most of this trouble is no longer an issue. By simply running the command bellow, it will automatically pull the WordPress version you want and also set up the tests directory for you.</p> <pre><code>./vendor/bin/wp-pest setup plugin --plugin-slug my-plugin --wp-version 6.4.4\n</code></pre> <p>Tip</p> <p>If you use matapatos/wp-fastendpoints-my-plugin you can use the already configured <code>composer setup:wp:6.x</code> commands</p>"},{"location":"quick-start/tests/integration/#optional-changes","title":"Optional changes","text":"<p>If you take a closer look at the resultant tests structure you might notice that is slightly different from the one previously mentioned. These changes are not mandatory and so, feel free to skip this section \u23e9</p> <p>The main reason of these differences is to allow us to run tests without the need to always specify a group of tests. Those changes include:</p> <pre><code>&lt;?php\n/**\n* tests/Helpers.php\n */ \nnamespace MyPlugin\\Tests;\n\nclass Helpers\n{\n    /**\n     * Checks if weather we want to run integration tests or not\n     */\n    public static function isIntegrationTest(): bool\n    {\n        return isset($GLOBALS['argv']) &amp;&amp; in_array('--group=integration', $GLOBALS['argv'], true);\n    }\n}\n</code></pre> <pre><code>&lt;?php\n/**\n* tests/Integration/*Test.php\n */ \nnamespace MyPlugin\\Tests\\Integration;\n\nuse MyPlugin\\Tests\\Helpers;\n\n// Needs to add this check to every Integration test file\nif (! Helpers::isIntegrationTest()) {\n    return;\n}\n</code></pre>"},{"location":"quick-start/tests/integration/#our-integration-test","title":"Our integration test \ud83d\ude43","text":"<p>Now that everything is configured we can start creating integration tests:</p> <pre><code>&lt;?php\ntest('Create a new post', function () {\n    // Create user with correct permissions\n    $userId = $this::factory()-&gt;user-&gt;create();\n    $user = get_user_by('id', $userId);\n    $user-&gt;add_cap('publish_posts');\n    // Make request as that user\n    wp_set_current_user($userId);\n    $request = new \\WP_REST_Request('POST', '/my-plugin/v1/posts');\n    $request-&gt;set_body_params([\n        'post_title' =&gt; 'My testing message',\n        'post_status' =&gt; 'publish',\n        'post_type' =&gt; 'post',\n        'post_content' =&gt; '&lt;p&gt;Message body&lt;/p&gt;',\n    ]);\n    $response = $this-&gt;server-&gt;dispatch($request);\n    expect($response-&gt;get_status())-&gt;toBe(200);\n    $postId = $response-&gt;get_data();\n    // Check that the post details are correct\n    expect(get_post($postId))\n        -&gt;toBeInstanceOf(\\WP_Post::class)\n        -&gt;toHaveProperty('post_title', 'My testing message')\n        -&gt;toHaveProperty('post_status', 'publish')\n        -&gt;toHaveProperty('post_type', 'post')\n        -&gt;toHaveProperty('post_content', '&lt;p&gt;Message body&lt;/p&gt;');\n})-&gt;group('api', 'posts');\n</code></pre> <p>Here, we take advantage of the existent testing factories to create a single user with the necessary capability to publish posts. Then, we make mimic a REST request from that given user, and lastly, we check if that blog post was created.</p>"},{"location":"quick-start/tests/unit/","title":"Unit Tests","text":"<p>As an example of a unit test, we are going add a test to check the 1) request payload schema used and 2) the necessary user permissions on the endpoint that allows a user to create a new blog post.</p> <p>We could have separated each assertion in its own unit test but for the sake of simplicity we are going to make both of them in the same test.</p> <pre><code>&lt;?php\ntest('Creating post endpoint has correct permissions and schema', function () {\n    // Create endpoint mock\n    $endpoint = Mockery::mock(Endpoint::class);\n    // Assert that the request payload schema passed is correct\n    $endpoint\n        -&gt;shouldReceive('schema')\n        -&gt;once()\n        -&gt;with('Posts/CreateOrUpdate')\n        -&gt;andReturnSelf();\n    // Assert that user permissions are correct\n    $endpoint\n        -&gt;shouldReceive('hasCap')\n        -&gt;once()\n        -&gt;with('publish_posts');\n    // Create router. Make sure that var name matches your router variable\n    $router = Mockery::mock(Router::class)\n        -&gt;makePartial();\n    // Assert that router endpoint is called\n    $router\n        -&gt;shouldReceive('post')\n        -&gt;once()\n        -&gt;with('/', Mockery::type('callable'))\n        -&gt;andReturn($endpoint);\n    // Needed to attach endpoints\n    require \\ROUTERS_DIR.'/Posts.php';\n})-&gt;group('api', 'posts');\n</code></pre> <p>The reason we are able to make the assertions above is due to this line. Specially, regarding this part <code>$router ??</code>. This allows us to replace our original router with our mocked version.</p> <p>As you might notice, this is just pure PHP code nothing magical! \ud83e\ude84</p>"}]}